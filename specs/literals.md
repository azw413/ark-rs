# Ark Bytecode `.abc` Literal Table Specification
*(Developer-facing reference for implementers of readers/writers)*

Version: Draft 1.0 (based on Dayu / Ark Runtime reverse-engineering)
Author: Generated by ChatGPT  
Date: 2025-10-29  

---

## 1  Overview

The **Literal Table** in an `.abc` file encodes static literal values used by
functions, classes, and modules at runtime.  
Each entry is a `LiteralArray` containing one or more `Literal` values in
**Tag–Value** format.  
These literals represent numeric constants, strings, arrays, `null`,
`undefined`, etc.

The layout and semantics are derived from reverse-engineered structures used in
the **Dayu** project and the **ArkCompiler ets_runtime** sources.

---

## 2  LiteralArray Section

Each `LiteralArray` is a contiguous structure consisting of:

```text
+----------------+------------------+
| Field          | Type             |
+----------------+------------------+
| num_literals   | uint32_le        |
| literals[...]  | Literal[num_literals]
+----------------+------------------+
2.1 Fields
Field	Type	Description
num_literals	u32 LE	Number of Literal entries that follow. In some legacy versions this value must be divided by 2 to obtain the true count (see § 7).
literals	array	Sequence of Literal entries (see § 3).

2.2 Alignment
All fields are byte-aligned (no extra padding).
Literal arrays may immediately follow one another.

3 Literal Structure
Each literal is a single tag byte followed by a value payload whose
format depends on the tag.

text
Copy code
+---------+---------------------------+
| Field   | Type / Size               |
+---------+---------------------------+
| tag     | uint8                     |
| value   | variable length (depends) |
+---------+---------------------------+
rust
Copy code
pub enum Literal {
    Empty,
    Int(i64),
    Float(f32),
    Double(f64),
    StringIdx(u32),
    TypeIdx(u32),
    Null,
    Bool(bool),
    Array(Vec<Literal>),
    BigInt(Vec<u8>),      // arbitrary precision bytes
    Any { type_idx: u32, data: Vec<u8> },
    Undefined,
    Unknown { tag: u8, raw: Vec<u8> },
}
4 Tag → Value Map
Tag (hex)	Identifier	Value Format	Notes
00	EMPTY	—	Placeholder / end marker.
01	INT_VALUE	sleb128	Signed integer constant.
02	FLOAT_VALUE	u32_le (IEEE 754 float32)	Bitwise float32.
03	DOUBLE_VALUE	u64_le (IEEE 754 float64)	Bitwise float64.
04	STRING_LITERAL	u32_le → string pool index	Points into constant pool.
05	TYPE_LITERAL	u32_le → type pool index	Type descriptor.
06	NULL_LITERAL	—	Represents null.
07	ARRAY_LITERAL	u32_le count + repeated Literal	Recursive container.
08	BOOLEAN_LITERAL	u8 (0 = false / 1 = true)	Sometimes replaced by `INT_VALUE(0
09	BIGINT_LITERAL	u32_le len + len bytes	Arbitrary precision integer.
0A	ANY_LITERAL	u32_le type_idx + u32_le len + bytes	“Any” dynamic literal.
0B	UNDEFINED_LITERAL	—	JavaScript/TS undefined.

Warning: Tag assignments may change between .abc versions.
Always fall back to Unknown{tag,raw} for unrecognised values.

5 Encoding Rules
5.1 Integer Encoding
Integers are signed LEB128:

text
Copy code
byte = value & 0x7F
if more bytes: set bit 7
repeat until (value == 0 or −1) and (bit 6 of last == sign bit)
Example:

mathematica
Copy code
42  => 2A
−2  => 7E
128 => 80 01
5.2 Float / Double
Stored as raw IEEE-754 bits in little-endian order.

5.3 Array Literals
perl
Copy code
u32_le length
Literal[length]
If the parsed number seems twice the real number of items,
apply the half-count rule (§ 7.1).

5.4 String / Type References
The payload is a u32_le constant-pool index.
No embedded NUL or length prefix here.

5.5 Boolean
Single byte 0 or 1.

6 Parsing Algorithm (Reference Rust)
rust
Copy code
fn read_literal(r: &mut Reader, version: Version) -> Literal {
    let tag = r.u8();
    match tag {
        0x01 => Literal::Int(r.sleb128()),
        0x02 => Literal::Float(f32::from_bits(r.u32())),
        0x03 => Literal::Double(f64::from_bits(r.u64())),
        0x04 => Literal::StringIdx(r.u32()),
        0x05 => Literal::TypeIdx(r.u32()),
        0x06 => Literal::Null,
        0x07 => {
            let raw = r.u32();
            let count = if version.half_literal_count() { raw / 2 } else { raw };
            let mut items = Vec::with_capacity(count as usize);
            for _ in 0..count { items.push(read_literal(r, version)); }
            Literal::Array(items)
        }
        0x08 => Literal::Bool(r.u8() != 0),
        0x09 => {
            let len = r.u32() as usize;
            Literal::BigInt(r.bytes(len))
        }
        0x0A => {
            let type_idx = r.u32();
            let len = r.u32() as usize;
            let data = r.bytes(len);
            Literal::Any { type_idx, data }
        }
        0x0B => Literal::Undefined,
        _ => {
            // unknown tag
            let mut buf = Vec::new();
            r.read_to_end_literal(&mut buf, tag);
            Literal::Unknown { tag, raw: buf }
        }
    }
}
7 Version-Dependent Behaviour
7.1 Half-Count Rule
Some ABC versions (≤ v12.0.1.0) encode num_literals and array lengths
as twice the actual number of entries.
Reason unknown (possibly legacy word alignment).

Implement detection:

rust
Copy code
fn half_literal_count(&self) -> bool {
    self.major < 13
}
7.2 Future Tags
Ark Runtime may add tags above 0x0B for
Symbol, FunctionRef, or ModuleRef.
Parsers should skip unknown values gracefully.

8 Serialization Example
rust
Copy code
fn write_literal(w: &mut Writer, lit: &Literal, v: Version) {
    match lit {
        Literal::Int(x) => { w.u8(0x01); w.sleb128(*x); }
        Literal::Float(f) => { w.u8(0x02); w.u32(f.to_bits()); }
        Literal::Double(d) => { w.u8(0x03); w.u64(d.to_bits()); }
        Literal::StringIdx(i) => { w.u8(0x04); w.u32(*i); }
        Literal::Array(arr) => {
            w.u8(0x07);
            let cnt = if v.half_literal_count() { (arr.len() * 2) as u32 } else { arr.len() as u32 };
            w.u32(cnt);
            for l in arr { write_literal(w, l, v); }
        }
        Literal::Null => w.u8(0x06),
        Literal::Bool(b) => { w.u8(0x08); w.u8(*b as u8); }
        Literal::BigInt(bytes) => { w.u8(0x09); w.u32(bytes.len() as u32); w.bytes(bytes); }
        Literal::Any { type_idx, data } => {
            w.u8(0x0A);
            w.u32(*type_idx);
            w.u32(data.len() as u32);
            w.bytes(data);
        }
        Literal::Undefined => w.u8(0x0B),
        Literal::Unknown { tag, raw } => { w.u8(*tag); w.bytes(raw); }
        _ => w.u8(0x00),
    }
}
9 Example Hex Dump
pgsql
Copy code
07                ; tag = ARRAY_LITERAL
04 00 00 00       ; length = 4
01 2A             ; INT(42)
04 0C 00 00 00    ; STRING idx=12
06                ; NULL
08 01             ; BOOL(true)
Interpreted as:

pgsql
Copy code
Array [
  Int(42),
  StringIdx(12),
  Null,
  Bool(true)
]
10 Testing Checklist
 Validate literal counts vs. actual bytes read.

 Cross-verify string/type indices exist in constant pool.

 Round-trip encode → decode yields identical bytes.

 Verify float/double endian correctness.

 Test both “normal” and “half-count” versions.

 Gracefully skip unknown tags.

11 References
hx1997 / dayu

hx1997 / ark-bytecode-010editor-template

seaxiang.com blog Ark Bytecode Analysis

HarmonyOS ArkCompiler source (ETS runtime)